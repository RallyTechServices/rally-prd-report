<!DOCTYPE html>
<html>
<head>
    <title>Rally PRD Report</title>
    <!--  (c) 2013 Rally Software Development Corp.  All Rights Reserved. -->
    <!--  Build Date: Wed Nov 27 2013 11:06:31 GMT-0700 (Mountain Standard Time) -->
    
    <script type="text/javascript">
        var APP_BUILD_DATE = "Wed Nov 27 2013 11:06:31 GMT-0700 (Mountain Standard Time)";
        var CHECKSUM = 111894932743;
    </script>
    
    <script type="text/javascript" src="https://rally1.rallydev.com/apps/2.0rc1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
/**
 * A link that pops up a version dialog box
 */

Ext.define('Rally.technicalservices.InfoLink',{
    extend: 'Ext.Component',
    alias: 'widget.tsinfolink',
    
    /**
     * @cfg {String} informationHtml
     * Additional text to be displayed on the popup dialog (for exmaple,
     * to add a description of the app's use or functionality)
     */
    informationHtml: null,
    
    /**
     * 
     * cfg {String} title
     * The title for the dialog box
     */
     text: "Information",
    
    renderTpl: "<div id='{id}-infolinkWrap' class='tsinfolink'>TS</div>",

    initComponent: function() {
        this.callParent(arguments);
       
    },
    
    onRender: function() {
        this.callParent(arguments);
        this.mon(this.el,'click',this.onClick,this);
    },
    _generateChecksum: function(string){
        var chk = 0x12345678,
            i;
        string = string.replace(/var CHECKSUM = .*;/,"");
        
        for (i = 0; i < string.length; i++) {
            chk += (string.charCodeAt(i) * i);
        }
    
        return chk;
    },
    _checkChecksum: function(container) {
        var me = this;
        Ext.Ajax.request({
            url: document.URL,
            params: {
                id: 1
            },
            success: function (response) {
                text = response.responseText;
                if ( CHECKSUM ) {
                    if ( CHECKSUM !== me._generateChecksum(text) ) {
                        console.log("Checksums don't match!");
                        if ( me.dialog ) {
                            me.dialog.add({xtype:'container',html:'Checksums do not match'});
                        }
                    }
                }
            }
        });
    },
    onClick: function(e) {
        var me = this;
        this._checkChecksum(this);
        
        var dialog_items = [];
        
        if ( this.informationHtml ) {
            dialog_items.push({
                xtype:'container',
                html: this.informationHtml
            });
        }
                
        dialog_items.push({
            xtype:'container',
            html:"This app was created by the Rally Technical Services Team."
        });
        
        if ( APP_BUILD_DATE ) {
            dialog_items.push({
                xtype:'container',
                html:'Build date/time: ' + APP_BUILD_DATE
            });
        }
        
        if (this.dialog){this.dialog.destroy();}
        this.dialog = Ext.create('Rally.ui.dialog.Dialog',{
            defaults: { padding: 5, margin: 5 },
            closable: true,
            draggable: true,
            title: me.title,
            items: dialog_items
        });
        this.dialog.show();
    }
});
/*
 */
Ext.define('Rally.technicalservices.Logger',{
    constructor: function(config){
        Ext.apply(this,config);
    },
    log: function(args){
        var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
        //var output_args = arguments;
        //output_args.unshift( [ "[ " + timestamp + " ]" ] );
        //output_args = Ext.Array.push(output_args,arguments);
        
        var output_args = [];
        output_args = Ext.Array.push(output_args,[timestamp]);
        output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments,0));

        window.console && console.log.apply(console,output_args);
    }

});

var user_cache = {};

Ext.define('TSLookbackGetters', {
    singleton:  true,
    getStateChangeAuthor:  function(record, callback){
        TSLookbackGetters.getStateChangeInfo(record,  callback,  "change_author");
    },
    getStateChangeDate:  function(record, callback){
        TSLookbackGetters.getStateChangeInfo(record,  callback,  "change_date");
    },
    getStateChangeInfo:  function(record, callback, flag) {
        var me = this;
        var feature_oid = record.get('ObjectID');

        var state_field = 'State';
        if ( record.get('_type') === 'testcase' ) {
            state_field = 'LastVerdict';
        }
        if ( ! record.get(state_field) ) {
            callback("");
        } else {
            var state = record.get(state_field);
            if ( state.ObjectID ) {
                state = state.ObjectID;
            }
//            if ( record.get('_type') === "task" ) {
//                state = record.get('State').ObjectID;
//            }

            var value = null;

            Ext.create('Rally.data.lookback.SnapshotStore', {
                filters: [
                    {property: 'ObjectID', value: feature_oid},
                    {property: 'State', value: state},
                    {property: '_PreviousValues.State', operator: '!=', value: state},
                    {property: '_PreviousValues.State', operator: 'exists', value: true}
                ],
                fetch:  ['_ValidFrom', '_User'],
                autoLoad:  true,
                listeners:  {
                    scope:  this,
                    load:  function(store, snaps) {

                        Ext.Array.each(snaps, function(snap){
                            var user_oid = snap.get('_User');
                            var change_date = Rally.util.DateTime.fromIsoString(snap.get('_ValidFrom'));

                            if ( flag === "change_date" ) {
                                callback(change_date);
                            } else {
                                if ( user_cache[user_oid] ) {
                                    callback(user_cache[user_oid]);
                                } else {
                                    Ext.create('Rally.data.WsapiDataStore', {
                                        model: 'User',
                                        autoLoad: true,
                                        filters: {property: 'ObjectID', value: user_oid},
                                        listeners:  {
                                            load:  function(store, records){
                                                user_cache[user_oid] = records[0].get('UserName');
                                                callback(user_cache[user_oid]);
                                            }
                                        }
                                    });
                                }
                            }

                        });

                    }
                }
            });
        }
    },
    getScheduleStateChangeAuthor:  function(record, callback){
        TSLookbackGetters.getScheduleStateChangeInfo(record, callback, 'change_author');
    },
    getScheduleStateChangeDate:  function(record, callback){
        TSLookbackGetters.getScheduleStateChangeInfo(record, callback, 'change_date');
    },
    getScheduleStateChangeInfo:  function(record, callback, flag){
        var me = this;
        var story_oid = record.get('ObjectID');
        var schedule_state = record.get('ScheduleState');

        var value = null;

        Ext.create('Rally.data.lookback.SnapshotStore', {
            filters: [
                {property: 'ObjectID', value: story_oid},
                {property: 'ScheduleState', value: schedule_state},
                {property: '_PreviousValues.ScheduleState', operator: '!=', value: schedule_state},
                {property: '_PreviousValues.ScheduleState', operator: 'exists', value: true}
            ],
            fetch:  ['_ValidFrom', '_User'],
            autoLoad:  true,
            listeners:  {
                scope:  this,
                load:  function(store, snaps){
                    Ext.Array.each(snaps, function(snap){
                        var user_oid = snap.get('_User');
                        var change_date = Rally.util.DateTime.fromIsoString(snap.get('_ValidFrom'));

                        if ( flag === "change_date" ) {
                            callback(change_date);
                        } else {
                            if ( user_cache[user_oid] ) {
                                callback(user_cache[user_oid]);
                            } else {
                                Ext.create('Rally.data.WsapiDataStore', {
                                    model: 'User',
                                    autoLoad: true,
                                    filters: {property: 'ObjectID', value: user_oid},
                                    listeners:  {
                                        load:  function(store, records){
                                            user_cache[user_oid] = records[0].get('UserName');
                                            callback(user_cache[user_oid]);
                                        }
                                    }
                                });
                            }
                        }
                    });
                }
            }
        });
    }
});
Ext.define('TSRenderers',{
    singleton: true,

    renderPercent: function(value,record,app) {
        if ( ! value ) {
            return "";
        } else {
            return ( 100 * parseFloat(value,10) ) + "%";
        }
    },
    renderByFormattedID: function(value,record,app) {
        if ( ! value ) {
            return "--";
        } else if ( typeof(value.get) === 'function' ){
            return value.get('FormattedID');
        } else {
            return value.FormattedID;
        }
    },
    renderBySavedParent: function(value,record,app) {
        var display_value = "--";
        if ( app && app._feature_parents && record.get('Feature') ) {
            var feature_oid = record.get('Feature').ObjectID;
            if ( app._feature_parents[feature_oid] ) {
                display_value =  app._feature_parents[feature_oid];
            }
        }
        return display_value;
    }
});
/*
 * a model to hold not being a feature
 */

Ext.define('NonFeature',{
    extend:'Ext.data.Model',
    fields:[
        {name:'ObjectID',type:'integer',defaultValue:0},
        {name:'FormattedID',type:'string',defaultValue:"F0"},
        {name:'Parent',type:'string',defaultValue:null},
        {name:'Name',type:'string',defaultValue:"Sans Feature"}
    ]
});
/* Blob.js
 * A Blob implementation.
 * 2013-06-20
 * 
 * By Eli Grey, http://eligrey.com
 * By Devin Samarin, https://github.com/eboyjr
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self, unescape */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/Blob.js/blob/master/Blob.js */

if (!(typeof Blob === "function" || typeof Blob === "object") || typeof URL === "undefined")
if ((typeof Blob === "function" || typeof Blob === "object") && typeof webkitURL !== "undefined") self.URL = webkitURL;
else var Blob = (function (view) {
    "use strict";

    var BlobBuilder = view.BlobBuilder || view.WebKitBlobBuilder || view.MozBlobBuilder || view.MSBlobBuilder || (function(view) {
        var
              get_class = function(object) {
                return Object.prototype.toString.call(object).match(/^\[object\s(.*)\]$/)[1];
            }
            , FakeBlobBuilder = function BlobBuilder() {
                this.data = [];
            }
            , FakeBlob = function Blob(data, type, encoding) {
                this.data = data;
                this.size = data.length;
                this.type = type;
                this.encoding = encoding;
            }
            , FBB_proto = FakeBlobBuilder.prototype
            , FB_proto = FakeBlob.prototype
            , FileReaderSync = view.FileReaderSync
            , FileException = function(type) {
                this.code = this[this.name = type];
            }
            , file_ex_codes = (
                  "NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR "
                + "NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR"
            ).split(" ")
            , file_ex_code = file_ex_codes.length
            , real_URL = view.URL || view.webkitURL || view
            , real_create_object_URL = real_URL.createObjectURL
            , real_revoke_object_URL = real_URL.revokeObjectURL
            , URL = real_URL
            , btoa = view.btoa
            , atob = view.atob
            
            , ArrayBuffer = view.ArrayBuffer
            , Uint8Array = view.Uint8Array
        ;
        FakeBlob.fake = FB_proto.fake = true;
        while (file_ex_code--) {
            FileException.prototype[file_ex_codes[file_ex_code]] = file_ex_code + 1;
        }
        if (!real_URL.createObjectURL) {
            URL = view.URL = {};
        }
        URL.createObjectURL = function(blob) {
            var
                  type = blob.type
                , data_URI_header
            ;
            if (type === null) {
                type = "application/octet-stream";
            }
            if (blob instanceof FakeBlob) {
                data_URI_header = "data:" + type;
                if (blob.encoding === "base64") {
                    return data_URI_header + ";base64," + blob.data;
                } else if (blob.encoding === "URI") {
                    return data_URI_header + "," + decodeURIComponent(blob.data);
                } if (btoa) {
                    return data_URI_header + ";base64," + btoa(blob.data);
                } else {
                    return data_URI_header + "," + encodeURIComponent(blob.data);
                }
            } else if (real_create_object_URL) {
                return real_create_object_URL.call(real_URL, blob);
            }
        };
        URL.revokeObjectURL = function(object_URL) {
            if (object_URL.substring(0, 5) !== "data:" && real_revoke_object_URL) {
                real_revoke_object_URL.call(real_URL, object_URL);
            }
        };
        FBB_proto.append = function(data/*, endings*/) {
            var bb = this.data;
            // decode data to a binary string
            if (Uint8Array && (data instanceof ArrayBuffer || data instanceof Uint8Array)) {
                var
                      str = ""
                    , buf = new Uint8Array(data)
                    , i = 0
                    , buf_len = buf.length
                ;
                for (; i < buf_len; i++) {
                    str += String.fromCharCode(buf[i]);
                }
                bb.push(str);
            } else if (get_class(data) === "Blob" || get_class(data) === "File") {
                if (FileReaderSync) {
                    var fr = new FileReaderSync;
                    bb.push(fr.readAsBinaryString(data));
                } else {
                    // async FileReader won't work as BlobBuilder is sync
                    throw new FileException("NOT_READABLE_ERR");
                }
            } else if (data instanceof FakeBlob) {
                if (data.encoding === "base64" && atob) {
                    bb.push(atob(data.data));
                } else if (data.encoding === "URI") {
                    bb.push(decodeURIComponent(data.data));
                } else if (data.encoding === "raw") {
                    bb.push(data.data);
                }
            } else {
                if (typeof data !== "string") {
                    data += ""; // convert unsupported types to strings
                }
                // decode UTF-16 to binary string
                bb.push(unescape(encodeURIComponent(data)));
            }
        };
        FBB_proto.getBlob = function(type) {
            if (!arguments.length) {
                type = null;
            }
            return new FakeBlob(this.data.join(""), type, "raw");
        };
        FBB_proto.toString = function() {
            return "[object BlobBuilder]";
        };
        FB_proto.slice = function(start, end, type) {
            var args = arguments.length;
            if (args < 3) {
                type = null;
            }
            return new FakeBlob(
                  this.data.slice(start, args > 1 ? end : this.data.length)
                , type
                , this.encoding
            );
        };
        FB_proto.toString = function() {
            return "[object Blob]";
        };
        return FakeBlobBuilder;
    }(view));

    return function Blob(blobParts, options) {
        var type = options ? (options.type || "") : "";
        var builder = new BlobBuilder();
        if (blobParts) {
            for (var i = 0, len = blobParts.length; i < len; i++) {
                builder.append(blobParts[i]);
            }
        }
        return builder.getBlob(type);
    };
}(self));
/* FileSaver.js
 * A saveAs() FileSaver implementation.
 * 2013-01-23
 *
 * By Eli Grey, http://eligrey.com
 * License: X11/MIT
 *   See LICENSE.md
 */

/*global self */
/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,
  plusplus: true */

/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */

var saveAs = saveAs
  || (navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))
  || (function(view) {
    "use strict";
    var
          doc = view.document
          // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet
        , get_URL = function() {
            return view.URL || view.webkitURL || view;
        }
        , URL = view.URL || view.webkitURL || view
        , save_link = doc.createElementNS("http://www.w3.org/1999/xhtml", "a")
        , can_use_save_link =  !view.externalHost && "download" in save_link
        , click = function(node) {
            var event = doc.createEvent("MouseEvents");
            event.initMouseEvent(
                "click", true, false, view, 0, 0, 0, 0, 0
                , false, false, false, false, 0, null
            );
            node.dispatchEvent(event);
        }
        , webkit_req_fs = view.webkitRequestFileSystem
        , req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem
        , throw_outside = function (ex) {
            (view.setImmediate || view.setTimeout)(function() {
                throw ex;
            }, 0);
        }
        , force_saveable_type = "application/octet-stream"
        , fs_min_size = 0
        , deletion_queue = []
        , process_deletion_queue = function() {
            var i = deletion_queue.length;
            while (i--) {
                var file = deletion_queue[i];
                if (typeof file === "string") { // file is an object URL
                    URL.revokeObjectURL(file);
                } else { // file is a File
                    file.remove();
                }
            }
            deletion_queue.length = 0; // clear queue
        }
        , dispatch = function(filesaver, event_types, event) {
            event_types = [].concat(event_types);
            var i = event_types.length;
            while (i--) {
                var listener = filesaver["on" + event_types[i]];
                if (typeof listener === "function") {
                    try {
                        listener.call(filesaver, event || filesaver);
                    } catch (ex) {
                        throw_outside(ex);
                    }
                }
            }
        }
        , FileSaver = function(blob, name) {
            // First try a.download, then web filesystem, then object URLs
            var
                  filesaver = this
                , type = blob.type
                , blob_changed = false
                , object_url
                , target_view
                , get_object_url = function() {
                    var object_url = get_URL().createObjectURL(blob);
                    deletion_queue.push(object_url);
                    return object_url;
                }
                , dispatch_all = function() {
                    dispatch(filesaver, "writestart progress write writeend".split(" "));
                }
                // on any filesys errors revert to saving with object URLs
                , fs_error = function() {
                    // don't create more object URLs than needed
                    if (blob_changed || !object_url) {
                        object_url = get_object_url(blob);
                    }
                    if (target_view) {
                        target_view.location.href = object_url;
                    } else {
                        window.open(object_url, "_blank");
                    }
                    filesaver.readyState = filesaver.DONE;
                    dispatch_all();
                }
                , abortable = function(func) {
                    return function() {
                        if (filesaver.readyState !== filesaver.DONE) {
                            return func.apply(this, arguments);
                        }
                    };
                }
                , create_if_not_found = {create: true, exclusive: false}
                , slice
            ;
            filesaver.readyState = filesaver.INIT;
            if (!name) {
                name = "download";
            }
            if (can_use_save_link) {
                object_url = get_object_url(blob);
                save_link.href = object_url;
                save_link.download = name;
                click(save_link);
                filesaver.readyState = filesaver.DONE;
                dispatch_all();
                return;
            }
            // Object and web filesystem URLs have a problem saving in Google Chrome when
            // viewed in a tab, so I force save with application/octet-stream
            // http://code.google.com/p/chromium/issues/detail?id=91158
            if (view.chrome && type && type !== force_saveable_type) {
                slice = blob.slice || blob.webkitSlice;
                blob = slice.call(blob, 0, blob.size, force_saveable_type);
                blob_changed = true;
            }
            // Since I can't be sure that the guessed media type will trigger a download
            // in WebKit, I append .download to the filename.
            // https://bugs.webkit.org/show_bug.cgi?id=65440
            if (webkit_req_fs && name !== "download") {
                name += ".download";
            }
            if (type === force_saveable_type || webkit_req_fs) {
                target_view = view;
            }
            if (!req_fs) {
                fs_error();
                return;
            }
            fs_min_size += blob.size;
            req_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {
                fs.root.getDirectory("saved", create_if_not_found, abortable(function(dir) {
                    var save = function() {
                        dir.getFile(name, create_if_not_found, abortable(function(file) {
                            file.createWriter(abortable(function(writer) {
                                writer.onwriteend = function(event) {
                                    target_view.location.href = file.toURL();
                                    deletion_queue.push(file);
                                    filesaver.readyState = filesaver.DONE;
                                    dispatch(filesaver, "writeend", event);
                                };
                                writer.onerror = function() {
                                    var error = writer.error;
                                    if (error.code !== error.ABORT_ERR) {
                                        fs_error();
                                    }
                                };
                                "writestart progress write abort".split(" ").forEach(function(event) {
                                    writer["on" + event] = filesaver["on" + event];
                                });
                                writer.write(blob);
                                filesaver.abort = function() {
                                    writer.abort();
                                    filesaver.readyState = filesaver.DONE;
                                };
                                filesaver.readyState = filesaver.WRITING;
                            }), fs_error);
                        }), fs_error);
                    };
                    dir.getFile(name, {create: false}, abortable(function(file) {
                        // delete file if it already exists
                        file.remove();
                        save();
                    }), abortable(function(ex) {
                        if (ex.code === ex.NOT_FOUND_ERR) {
                            save();
                        } else {
                            fs_error();
                        }
                    }));
                }), fs_error);
            }), fs_error);
        }
        , FS_proto = FileSaver.prototype
        , saveAs = function(blob, name) {
            return new FileSaver(blob, name);
        }
    ;
    FS_proto.abort = function() {
        var filesaver = this;
        filesaver.readyState = filesaver.DONE;
        dispatch(filesaver, "abort");
    };
    FS_proto.readyState = FS_proto.INIT = 0;
    FS_proto.WRITING = 1;
    FS_proto.DONE = 2;

    FS_proto.error =
    FS_proto.onwritestart =
    FS_proto.onprogress =
    FS_proto.onwrite =
    FS_proto.onabort =
    FS_proto.onerror =
    FS_proto.onwriteend =
        null;

    view.addEventListener("unload", process_deletion_queue, false);
    return saveAs;
}(self));

if (typeof module !== 'undefined') module.exports = saveAs;
Ext.define('CustomApp',  {
    extend:  'Rally.app.App',
    componentCls:  'app',

    _feature_parents:  {},  /* key is feature objectID */
    _feature_oids:  [],
    _records:  {},  /* key is objectID,  a place that we keep all the records */

    _async_flags:  {},  /* for collating all the async calls */
    /**
     * _csv_fields is used to define the headers and content of the csv file.
     *
     *  The dataIndex should be the same as the record type's dataIndex
     *  UNLESS:
     *
     *  the different records will do something with the same field (like "state/schedule state"
     *  the field is a reference to an object
     *  the field will be gathered via a separate asynchronous call (e.g.,  to the lookback api)
     *
     *  In all the UNLESS cases,  put the name of the csvIndex into the dataIndex here AND THEN
     *  make sure that the csvIndex is set on the appropriate _<recordtype>_fields call.
     *
     *  See how Team/Project is handled,  for example
     */
    _csv_fields:  [
        {text: 'Project', dataIndex: '__project'},
        {text: 'Request', dataIndex: '__request'},
        {text: 'Feature', dataIndex: '__feature'},
        {text: 'WorkProduct', dataIndex: '__workProduct'},
        {text: 'Formatted ID', dataIndex: 'FormattedID'},
        {text: 'Name', dataIndex: 'Name'},
        {text: 'State', dataIndex: '__state'},
        {text: 'F - % Done By Story Count', dataIndex: '__doneByCount'},
        {text: 'F - ICD(s)', dataIndex: 'ICDsReqd'},
        {text: 'F - CR#', dataIndex: 'CR'},
        {text: 'F - PIRR', dataIndex: 'PIRR'},
        {text: 'US - CR#', dataIndex: 'CR', csvIndex: '__cr'},  /**because the same field name is on features***/
        {text: 'US - Story Source', dataIndex: 'StorySource'},
        {text: 'TA - Task Type', dataIndex: 'TaskType'},
        {text: 'TA - Code Review', dataIndex: 'CodeReview'},
        {text: 'TA - Unit Test', dataIndex: 'UnitTest'},
        {text: 'TA - Dependencies Identified', dataIndex: 'DependenciesIdentified'},
        {text: 'TA - Chg Man Pkg', dataIndex: 'Changeman Package'},
        {text: 'State Date', dataIndex: '__stateChangedDate'},
        {text: 'State Changed By', dataIndex: '__stateChangedBy'}

    ],
    _feature_fields: [
        {dataIndex: 'Parent', text: 'Request', renderer: TSRenderers.renderByFormattedID,  csvIndex: '__request'},
        {dataIndex: 'Project', text: 'Team', csvIndex: '__team'},
    ],

    _story_fields: [
        {dataIndex: 'Project', text: 'Project', csvIndex: '__project'},
        {dataIndex: 'Feature', text: 'Feature', renderer: TSRenderers.renderByFormattedID, csvIndex: '__feature'},
        {dataIndex: 'Name', text: 'Requirement', csvIndex: '__storyname'}
    ],

    _testcase_fields: [
        {dataIndex: 'LastVerdict', text: 'State', csvIndex: '__state'},
        {dataIndex: 'Project', text: 'Team', csvIndex: '__team'},
//        {dataIndex: TSLookbackGetters.getStateChangeAuthor, text: 'State Changed By', csvIndex: '__stateChangedBy'},
//        {dataIndex: TSLookbackGetters.getStateChangeDate, text: 'State Date', csvIndex: '__stateChangedDate'},
        {dataIndex: 'Feature', text: 'Feature', renderer: TSRenderers.renderByFormattedID, csvIndex: '__feature'},
        {dataIndex: 'Request', text: 'Request', renderer: TSRenderers.renderBySavedParent, csvIndex: '__request'},
        {dataIndex: 'WorkProduct', text: 'Work Product', renderer: TSRenderers.renderByFormattedID, csvIndex: '__workProduct'}
    ],


    logger:  new Rally.technicalservices.Logger(),

    items: [
        {
            xtype: 'container', itemId: 'selector_outer_box', layout: {type: 'hbox'}, padding: 10,
            items: [
                {xtype: 'container', itemId: 'type_box',  margin: 5},
                {xtype: 'container', itemId: 'selector_box',  margin: 5},
                {xtype: 'container', itemId: 'button_box', margin: 5}
            ]
        },
        {
            xtype: 'container',
            itemId: 'report_box',
            padding: 10
        },
        {
            xtype: 'tsinfolink'
        }
    ],

    launch:  function() {
        this.logger.log("Launching with context", this.getContext());
        this._addTypeSelector();
    },

    _addTypeSelector:  function(){
        var me = this;
        var states = Ext.create('Ext.data.Store',  {
            fields:  ['value',  'name'],
            data :  [
                {"value": "Tags",  "name": "Tagged Features"},
                {"value": "Feature",  "name": "Feature List"}
            ]
        });

        // Create the combo box,  attached to the states data store
        this.down('#type_box').add(Ext.create('Ext.form.ComboBox',  {
            fieldLabel:  'Selector Type',
            store:  states,
            queryMode:  'local',
            displayField:  'name',
            valueField:  'value',
            labelWidth:  80,
            listeners:  {
                scope:  this,
                change:  function(box, new_value){
                    this.down('#selector_box').removeAll();
                    this.down('#button_box').removeAll();

                    if ( new_value === "Release" ) {
                        this._addReleaseSelector();
                    } else {
                        this._addFeatureChooser();
                    }
                }
            }
        }));
    },

    _addReleaseSelector:  function() {
        var me = this;
        this.down('#selector_box').add({
            xtype: 'rallyreleasecombobox',
            itemId: 'releasebox',
            fieldLabel:  'Release: ',
            labelWidth:  50,
            listeners:  {
                change:  function(rb){
                    me._getFeatures();
                },
                ready:  function(rb){
                    me._getFeatures();
                }
            },
            value:  me._selected_release
        });
    },

    _addFeatureChooser:  function() {
        this.down('#selector_box').add({
            xtype:  'rallymultiobjectpicker',
            itemId: 'featurebox',
            modelType:  'portfolioitem/feature',
            listeners:  {
                scope:  this,
                blur:  function(box) {
                    if ( box.getValue().length > 0 ) {
                        this._getFeatures();
                    }
                }
            }
        });
    },

    _getIndices:  function(hashes){
        var indices = [];
        Ext.Array.each(hashes, function(hash){
            if ( typeof(hash.dataIndex) === "string" ) {
                indices.push(hash.dataIndex);
            }
        });
        return indices;
    },

    _buildFeatureHTML:  function(feature, html) {
        var me = this;
        if ( feature.get('Parent') ) {
            // save parent for future use
            me._feature_parents[feature.get('ObjectID')] = feature.get('Parent').FormattedID;
        }

        html.push("<div class='ts-feature' id='" + feature.get('ObjectID') + "'>");
            html.push("<span class='ts-feature-headline'>" + feature.get('FormattedID') + ":  " + feature.get('Name') + "</span>");
            // show details for selected fields
            if ( feature.get('ObjectID') ) {
                html.push("<div class='ts-feature-details'>");
                    Ext.Array.each(me._feature_fields, function(field){
                        html.push("<div><i>" + field.text + "</i>:  " + me._render(feature, field) + "</div>");
                    });
                html.push("</div>");
            }
            // make a container for the stories
            html.push("<div class='ts-story-divider'>Stories</div>");
            html.push("<div id='childof" + feature.get('ObjectID') + "' class='ts-story'>");
            html.push("</div></div>");

        html.push("</div>");
    },

    _resetData:  function() {
        this.down('#report_box').update();
        this._feature_parents = {};
        this._features = [];
        this._records = [];
    },

    _getFeatures:  function() {
        var me = this;
        this.logger.log('_getFeatures');
        this._resetData();

        this.down('#button_box').removeAll();

        if ( this.down('#selector_outer_box').getEl() ) {
            this.down('#selector_outer_box').getEl().mask("Loading...");
        }

        var filters = [];
        var search_type = "release";

        if ( this.down('#releasebox') ) {
            var release = this.down('#releasebox').getRecord();
            this.logger.log('release', release.get('Name'));
            filters.push({property: 'Release.Name', value: release.get('Name')});
        } else {
            search_type = "features";
            var values = this.down('#featurebox').getValue();
            Ext.Array.each(values, function(value){
                filters.push({property: 'ObjectID', value: value.get('ObjectID')});
            });
            this.logger.log('filters', filters);
        }

        var filter_object = Ext.create('Rally.data.QueryFilter', filters[0]);
        for ( var i=1; i<filters.length; i++ ) {
            filter_object = filter_object.or(Ext.create('Rally.data.QueryFilter', filters[i]));
        }

        var fetch = Ext.Array.push(
            ['ObjectID', 'FormattedID', 'Name'],
            this._getIndices(this._feature_fields)
        );


        Ext.create('Rally.data.WsapiDataStore', {
            model: 'PortfolioItem/Feature',
            autoLoad:  true,
            filters: filter_object,
            fetch: fetch,
            listeners:  {
                scope:  this,
                load:  function(store, records, successful, opts){
                    var html = [];

                    if ( search_type !== "features" ) {
                        var non_feature = Ext.create('NonFeature', {});
                        me._buildFeatureHTML(non_feature, html);
                    }

                    Ext.Array.each(records, function(feature) {
                        me._buildFeatureHTML(feature, html);
                    });

                    this.down('#report_box').add({xtype: 'container', html: html.join('')});

                    if ( search_type !== "features" ) {
                        me._features.push(0);
                        me._records[0] = non_feature;
                        me._getStories(non_feature);
                    }

                    Ext.Array.each(records,  function(feature){
                        var oid = feature.get('ObjectID');
                        me._features.push(oid);
                        me._records[oid] = feature;
                        me._async_flags["feature" + oid] = 1;
                        me._getStories(feature);
                    });

                }
            }
        });
    },

    _getStories:  function(feature){
        var me = this;
        this.logger.log('_getStories', feature.get('FormattedID'));
        var feature_oid = feature.get('ObjectID');

        var filters = [
            {property: 'DirectChildrenCount', value: 0}
        ];
        if ( feature_oid > 0) {
            filters.push({property: 'Feature.ObjectID', value: feature_oid});
        } else {
            filters.push({property: 'Feature', value: ""});
            if ( this.down('#releasebox') ) {
                var release = this.down('#releasebox').getRecord();
                filters.push({property: 'Release.Name', value: release.get('Name')});
            }
        }
        var fetch = Ext.Array.push(['ObjectID', 'ScheduleState', 'FormattedID', 'Name'], this._getIndices(this._story_fields));

        Ext.create('Rally.data.WsapiDataStore', {
            model: 'UserStory',
            autoLoad:  true,
            filters: filters,
            fetch: fetch,
            limit: Infinity,
            listeners:  {
                scope:  this,
                load:  function(store, stories){
                    var html = [];
                    if ( stories.length === 0 ) {
                        html.push("No associated stories");
                    }
                    Ext.Array.each(stories, function(story) {
                        html.push("<div class='ts-story-headline' id='" + story.get('ObjectID') + "'>");
                        html.push(story.get('FormattedID') + ":  " + story.get('Name'));
                        html.push("</div>");
                        html.push("<div>");

                            // show details for selected fields
                            html.push("<div class='ts-story-details'>");
                                Ext.Array.each(me._story_fields, function(field){
                                    html.push("<div><i>" + field.text + "</i>:  " + me._render(story, field) + "</div>");
                                });
                            html.push("</div>");

                            // make a container for the test info
                            html.push("<div class='ts-test-divider'>Tests</div>");
                            html.push("<div id='testchildof" + story.get('ObjectID') + "' class='ts-test'>");
                            html.push("</div>");

                            // make a container for the depencency info
                            html.push("<div class='ts-dependency-divider'>Dependencies</div>");
                            html.push("<div id='dependencychildof" + story.get('ObjectID') + "' class='ts-dependency'>");
                            html.push("</div>");

                            // make a container for the notes info
                            html.push("<div class='ts-notes-divider'>Comments</div>");
                            html.push("<div id='noteschildof" + story.get('ObjectID') + "' class='ts-notes'>");
                            html.push("</div>");

                        html.push("</div>");
                    });

                    var container = Ext.dom.Query.selectNode('#childof' + feature_oid);
                    container.innerHTML = html.join(' ');
                    delete this._async_flags["feature" + feature_oid];

                    Ext.Array.each(stories,  function(story){
                        var oid = story.get('ObjectID');
                        if ( ! feature.get('_stories') ) {
                            feature.set('_stories',  [oid]);
                        } else {
                            var oids = feature.get('_stories');
                            oids.push(oid);
                            feature.set('_records', oids);
                        }
                        story.set('_tasks', []);
                        story.set('_testcases', []);
                        story.set('_defects', []);

                        me._records[oid] = story;

                        me._async_flags["story_tc" + oid] = 1;
                        me._getTests(story);
                    });
                    this._finishLoading();
                }
            }
        });
    },

    _getTests:  function(story){
        var me = this;
        this.logger.log('_getTests', story.get('FormattedID'));
        var story_oid = story.get('ObjectID');

        var filters = [
            {property: 'WorkProduct.ObjectID', value: story_oid}
        ];
        var fetch = Ext.Array.push(['ObjectID', 'State', 'FormattedID', 'Name'], this._getIndices(this._testcase_fields));

        Ext.create('Rally.data.WsapiDataStore', {
            model: 'TestCase',
            autoLoad:  true,
            filters: filters,
            fetch: fetch,
            limit: Infinity,
            listeners:  {
                scope:  this,
                load:  function(store, cases){
                    var html = [];
                    if ( cases.length === 0 ) {
                        html.push("No associated test cases");
                    }
                    Ext.Array.each(cases, function(test) {
                        var test_oid = test.get('ObjectID');
                        test.set('Feature', story.get('Feature'));

                        html.push("<div class='ts-test-headline' id='" + test_oid+ "'>");
                        html.push(test.get('FormattedID') + ":  " + test.get('Name'));
                        html.push("</div>");
                        html.push("<div>");

                            // show details for selected fields
                            html.push("<div class='ts-test-details'>");
                                Ext.Array.each(me._testcase_fields, function(field){
                                    html.push("<div><i>" + field.text + "</i>:  " + me._render(test, field) + "</div>");
                                });
                            html.push("</div>");

                        html.push("</div>");

                        // save for later
                        me._records[test_oid] = test;
                        var oids = story.get('_testcases');
                        oids.push(test_oid);
                        story.set('_testcases', oids);
                    });

                    var container = Ext.dom.Query.selectNode('#testchildof' + story_oid);
                    container.innerHTML = html.join(' ');
                    delete this._async_flags["story_tc" + story_oid];

                    this._finishLoading();
                }
            }
        });
    },

    _getTasks:  function(story){
        var me = this;
        this.logger.log('_getTasks', story.get('FormattedID'));
        var story_oid = story.get('ObjectID');

        var base_filter = Ext.create('Rally.data.QueryFilter', {property: 'WorkProduct.ObjectID', value: story_oid});
        var type_filter = Ext.create('Rally.data.QueryFilter', {property: 'TaskType', operator: 'contains', value: 'Development'}).or(
            Ext.create('Rally.data.QueryFilter', {property: 'TaskType', value: 'DBA'})).or(
                Ext.create('Rally.data.QueryFilter', {property: 'TaskType', value: 'Sys-Admin - Broker Override'}));

        var filters = base_filter.and(type_filter);

        var fetch = Ext.Array.push(['ObjectID', 'State', 'FormattedID', 'Name'], this._getIndices(this._task_fields));

        Ext.create('Rally.data.WsapiDataStore', {
            model: 'Task',
            autoLoad:  true,
            filters: filters,
            fetch: fetch,
            limit: Infinity,
            listeners:  {
                scope:  this,
                load:  function(store, tasks){
                    var html = [];
                    if ( tasks.length === 0 ) {
                        html.push("No associated tasks");
                    }
                    Ext.Array.each(tasks, function(task) {
                        var task_oid = task.get('ObjectID');
                        task.set('Feature', story.get('Feature'));
                        html.push("<div class='ts-task-headline' id='" + task_oid + "'>");
                            html.push(task.get('FormattedID') + ":  " + task.get('Name'));
                        html.push("</div>");
                        html.push("<div>");

                            // show details for selected fields
                            html.push("<div class='ts-task-details'>");
                                Ext.Array.each(me._task_fields, function(field){
                                    html.push("<div><i>" + field.text + "</i>:  " + me._render(task, field) + "</div>");
                                });
                            html.push("</div>");

                        html.push("</div>");

                        // save for later
                        me._records[task_oid] = task;
                        var oids = story.get('_tasks');
                        oids.push(task_oid);
                        story.set('_tasks', oids);

                    });

                    var container = Ext.dom.Query.selectNode('#taskchildof' + story_oid);
                    container.innerHTML = html.join(' ');
                    delete this._async_flags["story_task" + story_oid];

                    this._finishLoading();
                }
            }
        });
    },

    _getDefects:  function(story){
        var me = this;
        this.logger.log('_getDefects', story.get('FormattedID'));
        var story_oid = story.get('ObjectID');

        var filters = [
            {property: 'Requirement.ObjectID', value: story_oid}
        ];
        var fetch = Ext.Array.push(['ObjectID', 'State', 'FormattedID', 'Name'], this._getIndices(this._defect_fields));

        Ext.create('Rally.data.WsapiDataStore', {
            model: 'Defect',
            autoLoad:  true,
            filters: filters,
            fetch: fetch,
            limit: Infinity,
            listeners:  {
                scope:  this,
                load:  function(store, defects){
                    var html = [];
                    if ( defects.length === 0 ) {
                        html.push("No associated defects");
                    }
                    Ext.Array.each(defects, function(defect) {
                        var defect_oid = defect.get('ObjectID');
                        defect.set('Feature', story.get('Feature'));
                        html.push("<div class='ts-defect-headline' id='" + defect.get('ObjectID') + "'>");
                            html.push(defect.get('FormattedID') + ":  " + defect.get('Name'));
                        html.push("</div>");
                        html.push("<div>");

                            // show details for selected fields
                            html.push("<div class='ts-defect-details'>");
                                Ext.Array.each(me._defect_fields, function(field){
                                    html.push("<div><i>" + field.text + "</i>:  " + me._render(defect, field) + "</div>");
                                });
                            html.push("</div>");

                        html.push("</div>");
                        // save for later
                        me._records[defect_oid] = defect;
                        var oids = story.get('_defects');
                        oids.push(defect_oid);
                        story.set('_defects', oids);

                    });

                    var container = Ext.dom.Query.selectNode('#defectchildof' + story_oid);
                    container.innerHTML = html.join(' ');
                    delete this._async_flags["story_defect" + story_oid];

                    this._finishLoading();
                }
            }
        });
    },
    _render:  function(record, field){
        var me = this;
        var index = field.dataIndex;
        var csvIndex = field.csvIndex;  // where to store the result of an async call

        if ( typeof(index) === "function" ) {
            var id = this.getId() + "_" +  new Date().getTime();
            var display_value = "<span id='" + id + "'>...</span>";

            this._async_flags[field.text + record.get('ObjectID')] = 1;
            record.set(csvIndex, "querying...");
            index(record,  function(value) {
                var span = Ext.query('#' + id);

                if ( span && span[0] ) {
                    span[0].innerHTML = value;
                } else {
                    display_value = value;
                }
                record.set(csvIndex, value);

                delete me._async_flags[field.text + record.get('ObjectID')];
                me._finishLoading();
            });
        } else {
            var value = record.get(index);

            var display_value = value;
            if ( field.renderer ){
                display_value = field.renderer(value, record, this);
            } else if ( value === null ) {
                display_value = '--';
            } else if ( typeof(value) == 'object' ) {
                if ( typeof(value.get) == 'function' ) {
                    display_value = value.get('_refObjectName');
                } else if ( value._refObjectName ){
                    display_value = value._refObjectName;
                } else {
                    display_value = value;
                }
            }
            if (csvIndex) {
                record.set(csvIndex, display_value);
            }
        }
        return display_value;
    },

    _isAbleToDownloadFiles:  function() {
        try {
            var isFileSaverSupported = !!new Blob();
        } catch(e){
            this.logger.log(" NOTE: This browser does not support downloading");
            return false;
        }
        return true;
    },

    _finishLoading:  function() {
        // validate we're done
        var flag_size = Ext.Object.getSize(this._async_flags);
        var me = this;

        if ( flag_size === 0 ) {

            if ( this.down('#selector_outer_box').getEl() ) {
                this.down('#selector_outer_box').getEl().unmask();
            }

            /* Comment out for now
            if ( this._isAbleToDownloadFiles() ) {
                this.down('#button_box').removeAll();
                this.down('#button_box').add({
                    xtype: 'rallybutton',
                    itemId: 'save_button',
                    text: 'Save As CSV',
                    handler:  function() {
                        me._makeCSV();
                    }
                });
            }
            **/
            this.logger.log("-- DONE --");
        } else {
            this.down('#button_box').removeAll();

            if ( this.down('#selector_outer_box').getEl() ) {
                this.down('#selector_outer_box').getEl().mask("Loading " + flag_size + " ...");
            }
            this.logger.log("still waiting ", this._async_flags);
        }
    },
    _getCSVLineFromRecord:  function(record, fields) {
        var csv_line = [];
        Ext.Array.each(fields, function(field){
            csv_line.push(record.get(field.dataIndex));
        });
        return '"' + csv_line.join('", "') + '"';
    },
    _makeCSV:  function() {
        var me = this;
        var file_name = "feature_details.csv";

        var file_content = [];
        var header_line = [];
        Ext.Array.each(me._csv_fields,  function(field){
            header_line.push(field.text);
        });
        file_content.push(header_line.join(', '));

        Ext.Array.each(me._features,  function(foid) {
            var feature = me._records[foid];
            file_content.push(me._getCSVLineFromRecord(feature, me._csv_fields));

            me.logger.log("F:  " + feature.get('FormattedID') + ": " + feature.get('__stateChangedBy'));
            Ext.Array.each(feature.get('_stories'),  function(soid){
                var story = me._records[soid];
                file_content.push(me._getCSVLineFromRecord(story, me._csv_fields));

                Ext.Array.each(story.get('_tasks'), function(toid){
                    file_content.push(me._getCSVLineFromRecord(me._records[toid], me._csv_fields));
                });
                Ext.Array.each(story.get('_defects'), function(doid){
                    file_content.push(me._getCSVLineFromRecord(me._records[doid], me._csv_fields));
                });
                Ext.Array.each(story.get('_testcases'), function(toid){
                    file_content.push(me._getCSVLineFromRecord(me._records[toid], me._csv_fields));
                });

            });
        });

        var blob = new Blob([file_content.join("\r\n")], {type: 'text/plain;charset=utf-8'});
        saveAs(blob, file_name);
    }
});

            
               Rally.launchApp('CustomApp', {
                   name: 'Rally PRD Report'
               });
        });
    </script>
    
    <style type="text/css">

.app {
}

.tsinfolink {
    position:absolute;
    right:0px;
    width:5%;
}

.ts-feature {
    margin-left: 8px;
    margin-top: 12px;
}

.ts-feature-headline {
    font-family:"Times New Roman",Times,serif;
    font-size:20px;
}


.ts-feature-details {
    margin-left: 4px;
}

.ts-story {
    margin-left: 16px;
}

.ts-story-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:18px;
    margin-left: 8px;
}

.ts-story-headline {
    font-family:"Times New Roman",Times,serif;
    font-size:16px;
    margin-top: 12px;
}

.ts-story-details {
}

.ts-test {
    margin-left: 16px;
}

.ts-test-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-left: 8px;
}

.ts-dependency {
    margin-left: 16px;
}

.ts-dependency-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-left: 8px;
}

.ts-notes {
    margin-left: 16px;
}

.ts-notes-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-left: 8px;
}

.ts-test-headline {
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-top: 12px;
}

.ts-test-details {
}

.ts-task {
    margin-left: 16px;
}

.ts-task-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-left: 8px;
}

.ts-task-headline {
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-top: 12px;
}

.ts-task-details {
}

.ts-defect {
    margin-left: 16px;
}

.ts-defect-divider {
    margin-top:12px;
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-left: 8px;
}

.ts-defect-headline {
    font-family:"Times New Roman",Times,serif;
    font-size:14px;
    margin-top: 12px;
}

.ts-defect-details {
}
    </style>

</head>
<body></body>
</html>